# Algorithm-Implementations
&nbsp; &nbsp; &nbsp; This repository includes the solutions to several practical algorithm and data structure questions. Each implementation is designed to demonstrate key concepts in computer science, such as recursion, data structures, divide-and-conquer strategies, and amortized analysis.

# Contents

**1.a) Second Largest Element in a List** 

&nbsp; &nbsp; &nbsp; A Python function to find the second largest element in an unsorted list.

  
- Time Complexity: O(n), as the list is traversed once.



**1.b) Reverse String Using Stack** 

&nbsp; &nbsp; &nbsp; A Python function that reverses a string using a stack data structure.
  
- Time Complexity: O(n), where n is the length of the string.



**2) Queue Implementation Using Two Stacks**

&nbsp; &nbsp; &nbsp; A Python class to implement a queue using two stacks.
  
- Time Complexity:

- 1. Enqueue: O(1)

- 2. Dequeue: O(n) in the worst case.



**3) Merge Sort Algorithm**

&nbsp; &nbsp; &nbsp;A Python implementation of the Merge Sort algorithm using divide-and-conquer.
  
- Time Complexity: O(n log‚Å°n).

- Space Complexity: O(n) due to additional memory usage during merging.



**4) Recursive Fibonacci Calculation**

&nbsp; &nbsp; &nbsp; A recursive Python function to calculate the nth Fibonacci number, along with an optimized memoized version for better performance.
  
- Time Complexity:

- 1. Recursive: O(2^n).

- 2. Memoized: O(n).



**5) Dynamic Array Simulation**

&nbsp; &nbsp; &nbsp; A Python simulation of a dynamic array that resizes itself when full, doubling its size with each resize operation.
  
- Amortized Complexity: O(1) average insertion time.

