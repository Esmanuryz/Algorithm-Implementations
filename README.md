# Algorithm-Implementations
This repository includes the solutions to several practical algorithm and data structure questions. Each implementation is designed to demonstrate key concepts in computer science, such as recursion, data structures, divide-and-conquer strategies, and amortized analysis.

#Contents

Second Largest Element in a List (Question 5.1)

Description: A Python function to find the second largest element in an unsorted list.
Time Complexity: O(n)O(n)O(n), as the list is traversed once.

Reverse String Using Stack (Question 5.2)

Description: A Python function that reverses a string using a stack data structure.
Time Complexity: O(n)O(n)O(n), where nnn is the length of the string.

Queue Implementation Using Two Stacks (Question 6)

Description: A Python class to implement a queue using two stacks.
Time Complexity:
Enqueue: O(1)O(1)O(1)
Dequeue: O(n)O(n)O(n) in the worst case.

Merge Sort Algorithm (Question 11)

Description: A Python implementation of the Merge Sort algorithm using divide-and-conquer.
Time Complexity: O(nlog‚Å°n)O(n \log n)O(nlogn).
Space Complexity: O(n)O(n)O(n) due to additional memory usage during merging.

Recursive Fibonacci Calculation (Question 12)

Description: A recursive Python function to calculate the nth Fibonacci number, along with an optimized memoized version for better performance.
Time Complexity:
Recursive: O(2n)O(2^n)O(2n).
Memoized: O(n)O(n)O(n).

Dynamic Array Simulation (Question 13)

Description: A Python simulation of a dynamic array that resizes itself when full, doubling its size with each resize operation.
Amortized Complexity: O(1)O(1)O(1) average insertion time.
