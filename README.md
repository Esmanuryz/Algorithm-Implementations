# Algorithm-Implementations
This repository includes the solutions to several practical algorithm and data structure questions. Each implementation is designed to demonstrate key concepts in computer science, such as recursion, data structures, divide-and-conquer strategies, and amortized analysis.

# Contents

## 1.a) Second Largest Element in a List 

  A Python function to find the second largest element in an unsorted list.
Time Complexity: O(n)O(n)O(n), as the list is traversed once.

## 1.b) Reverse String Using Stack 

  A Python function that reverses a string using a stack data structure.
Time Complexity: O(n)O(n)O(n), where nnn is the length of the string.

## 2) Queue Implementation Using Two Stacks 

  A Python class to implement a queue using two stacks.
Time Complexity:
Enqueue: O(1)O(1)O(1)
Dequeue: O(n)O(n)O(n) in the worst case.

## 3) Merge Sort Algorithm 

  A Python implementation of the Merge Sort algorithm using divide-and-conquer.
Time Complexity: O(nlog‚Å°n)O(n \log n)O(nlogn).
Space Complexity: O(n)O(n)O(n) due to additional memory usage during merging.

## 4) Recursive Fibonacci Calculation 

  A recursive Python function to calculate the nth Fibonacci number, along with an optimized memoized version for better performance.
Time Complexity:
Recursive: O(2n)O(2^n)O(2n).
Memoized: O(n)O(n)O(n).

## 5) Dynamic Array Simulation

  A Python simulation of a dynamic array that resizes itself when full, doubling its size with each resize operation.
Amortized Complexity: O(1)O(1)O(1) average insertion time.
